
### March 6, 2023

- ğŸ‘€ Preview
    
    Ğ¢Ğ°Ğº, ÑÑŒĞ¾Ğ³Ğ¾Ğ´Ğ½Ñ– Ğ±ÑƒĞ´ĞµĞ¼Ğ¾ Ñ€Ğ¾Ğ·Ğ³Ğ»ÑĞ´Ğ°Ñ‚Ğ¸ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¾Ğ²Ñ– Ñ‚Ğ¸Ğ¿Ğ¸, Ñ‚Ğ°Ğº ÑˆĞ¾ Ğ´Ğ°Ğ²Ğ°Ğ¹ Ñ‚Ñ€Ğ¾Ñ…Ğ¸ Ğ¿Ğ¾Ğ´Ğ¸Ğ²Ğ¸Ğ¼Ğ¾ÑÑŒ Ğ¿Ñ€Ğ¾ Ğ½Ğ¸Ñ…
    
    ĞœĞ¾Ğ¼ĞµĞ½Ñ‚Ğ¸ Ğ½Ğ° Ñ€Ğ¾Ğ·Ğ³Ğ»ÑĞ´:
    
    - [ ]  Dynamic arrays
        
        ### What is a dynamic array in C++?
        
        A dynamic array is an array whose size can be modified during program runtime.
        
        In C++, to create a dynamic array, we use theÂ newÂ keyword followed by the data type of the array and the number of elements to be allocated within a pair of square brackets.
        
        Once an array has been created, its size cannot be changed. However, a dynamic array can expand its size even after it has been filled. During the creation of an array, it is allocated a predetermined amount of memory. This is not the case with a dynamic array as it grows its memory size by a certain factor when there is a need.
        
        To create a dynamic array in C++, we use the following syntax:
        
        ```
        data_type* array_name = new data_type[length];
        
        https://www.guru99.com
        
        ```
        
        Here,Â data_typeÂ is the data type of the array,Â array_nameÂ is the name of the array, andÂ lengthÂ is the number of elements to be allocated.
        
        Once we are done with the array, we can free up the memory using theÂ deleteÂ operator.
        
        Use theÂ deleteÂ operator withÂ []Â to free the memory of all array elements.
        
        AÂ deleteÂ withoutÂ []Â frees the memory of only a single element.
        
        ```
        delete[] array_name;
        
        ```
        
        We can also initialize a dynamic array using an initializer list. To initialize a dynamic array, we use the following syntax:
        
        ```
        data_type* array_name{ new data_type[length]{initializer_list} };
        
        https://www.guru99.com
        
        ```
        
        Here,Â initializer_listÂ is the list of values to be assigned to the array elements.
        
        If we want to initialize the array to 0, we can leave theÂ initializer_listÂ empty.
        
        ```
        int* array{ new int[length]{} };
        
        https://www.guru99.com
        
        ```
        
        To increase the size of a dynamic array, we cannot modify the size of an already created array. We have to create a new array with a larger size, copy the elements of the old array to the new array, and then delete the old array. However, this technique is prone to errors, hence, it is recommended to use a collection class to do this for us rather than managing it ourselves.
        
        We can use theÂ vectorÂ class in C++, which is essentially a dynamic array that resizes automatically as required.
        
        We can use theÂ push_back()Â function to add elements to the end of the vector.
        
        ```cpp
        #include <iostream>
        #include <vector>
        
        int main() {
            std::vector<int> values;
        
            // Read in values
            int value;
            while (std::cin >> value) {
                values.push_back(value);
            }
        
            // Print them back out
            for (std::size_t i(0), len(values.size()); i != len; ++i) {
                std::cout << values[i];
            }
        }
        
        https://stackoverflow.com
        
        ```
        
        In conclusion, a dynamic array is a useful tool in C++ to manage data whose size is unknown or changes during program runtime.
        
        It is created using theÂ newÂ keyword and can be initialized using an initializer list.
        
        To increase the size of a dynamic array, we have to create a new array with a larger size, copy the elements of the old array to the new array, and then delete the old array.
        
        However, it is recommended to use a collection class like theÂ vectorÂ class in C++ to manage dynamic arrays automatically.
        
        ### How can we delete and element from a dynamic array?
        
        To remove an element from a dynamic array in C++, we have to create a new array without the element we want to remove and copy all the remaining elements to the new array.Â We then delete the old array and assign the new array to the old array's pointer.
        
        Here is an example code that removes an element from a dynamic array:
        
        ```cpp
        int* array = new int[5]{1, 2, 3, 4, 5};
        int size = 5;
        int index = 2; // Index of element to remove
        
        // Create new array without the element to remove
        int* new_array = new int[size - 1];
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (i != index) {
                new_array[j] = array[i];
                j++;
            }
        }
        
        // Delete old array and assign new array to old array's pointer
        delete[] array;
        array = new_array;
        size--;
        
        // Print out the new array
        for (int i = 0; i < size; i++) {
            std::cout << array[i] << " ";
        }
        
        https://stackoverflow.com
        
        ```
        
        In this example, we have an array of size 5 with elements {1, 2, 3, 4, 5}. We want to remove the element at index 2, which is the number 3. We create a new array of size 4 and copy all the elements from the old array to the new array except for the element at index 2.Â We then delete the old array and assign the new array to the old array's pointer.Â Finally, we print out the new array which is {1, 2, 4, 5}.
        
    - [ ]  Copy constructor
        
        ### What is a copy constructor?
        
        A copy constructor is a special type of constructor in C++, which is used to initialize an object using another object of the same class. It is a member function of a class that takes an object of the same class as a reference parameter. Here are some key points about copy constructors:
        
        - A copy constructor is called whenever an object is initialized (by direct-initialization or copy-initialization) from another object of the same type.
        - The copy constructor is used to create a copy of an object, which has its own memory to hold the data.
        - If a copy constructor is not defined by the programmer, the compiler generates one by default.
        - The implicitly defined copy constructor copies the object representation (as by memmove).
        - A user-defined copy constructor is generally needed when an object owns pointers or non-shareable references, such as to a file, in which case a destructor and an assignment operator should also be written.
        - A copy constructor can be made private to prevent objects of a class from being copied.
        - A copy constructor is not called when an argument is passed by value, as it would create a non-terminating chain of calls.
        
        Here is an example of a copy constructor:
        
        ```cpp
        class Point {
        private:
            int x, y;
        public:
            Point(int x1, int y1) {
                x = x1;
                y = y1;
            }
            // Copy constructor
            Point(const Point& p1) {
                x = p1.x;
                y = p1.y;
            }
            int getX() { return x; }
            int getY() { return y; }
        };
        
        int main() {
            Point p1(10, 15); // Normal constructor is called here
            Point p2 = p1; // Copy constructor is called here
            // Let us access values assigned by constructors
            cout << "p1.x = " << p1.getX() << ", p1.y = " << p1.getY();
            cout << "\np2.x = " << p2.getX() << ", p2.y = " << p2.getY();
            return 0;
        }
        
        https://www.geeksforgeeks.org
        
        ```
        
        In this example, the copy constructor is defined to make a copy of the object by initializing it with the values of another object of the same class. The copy constructor is called when the object p2 is created by copying the object p1. The values of p1 are copied to p2, and each object has its own memory to hold the data.Â The getX() and getY() functions are used to access the values of x and y in each object.
        
        It is important to note that if a class has pointers or any runtime allocation of the resource like a file handle, a network connection, etc., a user-defined copy constructor should be written to ensure that pointers (or references) of copied objects point to new memory locations. Otherwise, the default copy constructor created by the compiler may not work as expected.
        
        ### ****How can I ensure that pointers of copied objects point to new memory locations?****
        
        In order to ensure that pointers of copied objects point to new memory locations, you need to define a user-defined copy constructor in C++. The default copy constructor created by the compiler only does a member-wise copy between objects, which means that pointers in the copied object will still point to the same memory locations as the original object.
        
        To perform a deep copy, you need to create a new memory location for the copied object's pointers to point to. This can be done in the user-defined copy constructor by allocating new memory and copying the data from the original object to the new memory location.
        
        Here is an example of a user-defined copy constructor that performs a deep copy:
        
        ```cpp
        class MyClass {
        private:
            int* data;
        public:
            // Constructor
            MyClass(int size) {
                data = new int[size];
            }
            // Copy constructor
            MyClass(const MyClass& other) {
                data = new int[other.size];
                for (int i = 0; i < other.size; i++) {
                    data[i] = other.data[i];
                }
            }
            // Destructor
            ~MyClass() {
                delete[] data;
            }
            // Assignment operator
            MyClass& operator=(const MyClass& other) {
                if (this != &other) {
                    delete[] data;
                    data = new int[other.size];
                    for (int i = 0; i < other.size; i++) {
                        data[i] = other.data[i];
                    }
                }
                return *this;
            }
        };
        
        int main() {
            MyClass obj1(5);
            // ... initialize obj1
            MyClass obj2 = obj1; // Copy constructor is called here
            // ... modify obj2
            obj1 = obj2; // Assignment operator is called here
            return 0;
        }
        
        https://www.geeksforgeeks.org
        
        ```
        
        In this example, the user-defined copy constructor creates a new memory location for the copied object's data pointer to point to, and copies the data from the original object to the new memory location. The destructor is also defined to free the memory allocated by the constructor. The assignment operator is also defined to perform a deep copy when an already initialized object is assigned a new value from another existing object.
        
        Note that it is important to define both the copy constructor and the assignment operator when dealing with objects that own pointers or non-shareable references.
        
        ### ****What are the advantages and disandvantages of a user-defined copy consturctor in C++?****
        
        Advantages of a user-defined copy constructor in C++:
        
        - A user-defined copy constructor allows for deep copying of objects that contain pointers or non-shareable references. This ensures that each object has its own memory to hold the data and that changes made to one object do not affect the other.
        - A user-defined copy constructor can be used to prevent objects of a class from being copied, by making the copy constructor private.Â This can be useful in situations where copying an object could [[lead]] to unexpected behavior, or where copying an object is not necessary.
        
        Disadvantages of a user-defined copy constructor in C++:
        
        - Writing a user-defined copy constructor can be time-consuming and error-prone, especially when dealing with complex objects that contain multiple pointers or non-shareable references.
        - If a copy constructor is not written correctly, it can [[lead]] to memory leaks or undefined behavior.
        - A user-defined copy constructor can make code more difficult to read and maintain, especially if it is not well-documented or if it deviates from the standard copy constructor behavior.
        
        Overall, the advantages of a user-defined copy constructor in C++ outweigh the disadvantages in situations where deep copying is necessary or where copying an object could [[lead]] to unexpected behavior. However, care must be taken when writing a user-defined copy constructor to ensure that it is correct and well-documented.
        
    - [ ]  Dynamic class types
        
        ### What are dynamic class types?
        
        Dynamic class types in C++ allow for the creation of custom data types and dynamic allocation of memory at runtime.Â This can be useful when handling complex [[Data structure|data structures]] or when creating objects with varying attributes. Here are some examples of how dynamic class types can be implemented in C++:
        
        - Creating custom data types as maps at runtime: This method involves creating a map that associates a member name to an IDataItem pointer, which can refer to some sub-class of IDataItem. This allows for the use of dynamic polymorphism to abstract away from the actual data when handling the containing structures.Â Here's an example of how this can be done:
        
        ```cpp
        class IDataItem {
          public:
            virtual ~IDataItem() {}
        };
        
        template<typename T>
        class DataItem : public IDataItem {
          public:
            T value;
        };
        
        class DataMap {
          public:
            void addDataItem(const std::string& name, IDataItem* item) {
              data[name] = item;
            }
        
            template<typename T>
            void addData(const std::string& name, const T& value) {
              DataItem<T>* item = new DataItem<T>();
              item->value = value;
              addDataItem(name, item);
            }
        
            template<typename T>
            T getData(const std::string& name) const {
              DataItem<T>* item = dynamic_cast<DataItem<T>*>(data[name]);
              if (item) {
                return item->value;
              } else {
                throw std::runtime_error("Invalid data type for " + name);
              }
            }
        
          private:
            std::map<std::string, IDataItem*> data;
        };
        
        https://www.geeksforgeeks.org
        
        ```
        
        - Using a factory pattern:Â This method involves creating a factory class that is responsible for creating objects of different types. The factory can be implemented using a template class that creates the relevant object and dynamically adds these to the factory.Â Here's an example of how this can be done:
        
        ```cpp
        class ObjectFactory {
          public:
            template<typename T>
            void registerObject() {
              creators[typeid(T).name()] = []() { return new T; };
            }
        
            template<typename T>
            T* createObject() {
              auto it = creators.find(typeid(T).name());
              if (it != creators.end()) {
                return dynamic_cast<T*>(it->second());
              } else {
                return nullptr;
              }
            }
        
          private:
            std::map<const char*, std::function<void*()>> creators;
        };
        
        https://stackoverflow.com
        
        ```
        
        - Using dynamic constructors: This method involves allocating memory dynamically using the new operator in a constructor. This allows for dynamic initialization of objects.Â Here's an example of how this can be done:
        
        ```cpp
        class Geeks {
          const char* p;
        
          public:
            Geeks() {
              p = new char[6];
              p = "geeks";
            }
        
            void display() {
              cout << p << endl;
            }
        };
        
        int main() {
          Geeks obj;
          obj.display();
        }
        
        https://www.geeksforgeeks.org
        
        ```
        
        Overall, dynamic class types in C++ provide flexibility and power to create custom data types and handle complex [[Data structure|data structures]].
        
        ### **What is a virtual function in c++? Provide code sampels**
        
        A virtual function in C++ is a function that is declared in a base class and can be redefined (overridden) in a derived class. When a derived class object is referred to using a pointer or a reference to the base class, a virtual function can be called for that object and execute the derived class's version of the function. Virtual functions ensure that the correct function is called for an object, regardless of the type of reference used for function [[call]]. Here is an example of how virtual functions can be implemented in C++:
        
        ```cpp
        class Shape {
           public:
              virtual int getArea() = 0; // pure virtual function
        };
        
        class Rectangle: public Shape {
           public:
              int getArea() {
                 return width * height;
              }
           private:
              int width;
              int height;
        };
        
        class Triangle: public Shape{
           public:
              int getArea() {
                 return (width * height)/2;
              }
           private:
              int width;
              int height;
        };
        
        https://stackoverflow.com
        
        ```
        
        In the above example,Â ShapeÂ is a base class with a pure virtual functionÂ getArea()Â which will be overridden in the derived classesÂ RectangleÂ andÂ Triangle.
        
        TheÂ getArea()Â function is declared as pure virtual by addingÂ = 0Â to the function declaration.
        
        This means that any derived class must implement this function.
        
        The derived classesÂ RectangleÂ andÂ TriangleÂ implement their own versions ofÂ getArea(), which will be called when the function is called on an object of that class.
        
        To use the virtual function, we can create an object of a derived class and [[call]] the function using a pointer or reference to the base class:
        
        ```cpp
        int main() {
           Shape* shape;
        
           Rectangle rec;
           Triangle  tri;
        
           shape = &rec;
           int area = shape->getArea();
           cout << "Rectangle area: " << area << endl;
        
           shape = &tri;
           area = shape->getArea();
           cout << "Triangle area: " << area << endl;
        
           return 0;
        }
        
        ```
        
        In the above example,Â shapeÂ is a pointer to the base classÂ Shape.
        
        We can assign objects of the derived classesÂ RectangleÂ andÂ TriangleÂ to this pointer and [[call]] theÂ getArea()Â function.
        
        The implementation ofÂ getArea()Â that is called will depend on the actual type of the object being referred to.
        
        Note that pure virtual functions can also be used to create abstract classes that cannot be instantiated directly, but can be used as a base class for other classes.
        
        ### **What is const char* in C++?**
        
        In C++,Â const char*Â is a pointer to a [[constant]] character string.
        
        This means that the characters in the string cannot be modified through the pointer. The const keyword is used to ensure that the value pointed to by the pointer remains [[constant]] throughout the program.
        
        For example, consider the following code snippet:
        
        ```
        const char* str = "Hello World";
        ```
        
        Here,Â strÂ is a pointer to a [[constant]] character string.
        
        The characters in the string "Hello World" cannot be modified through the pointerÂ str.
        
        To convert aÂ const char*Â to aÂ char*, you can use a type [[cast]].
        
        However, as mentioned in the comments on the Stack Overflow questions, this can be dangerous and should only be done if necessary.
        
        If the string is actually a string literal or is otherwise immutable, modifying it through aÂ char*Â can result in undefined behavior and program crashes.
        
        If you need to modify a string, it is best to create a copy of the string and modify the copy.
        
        One way to do this is to use theÂ strdup()Â function, which allocates memory for a copy of the string and returns a pointer to the copy.
        
        Here is an example:
        
        ```cpp
        const char* const_str = "Hello World";
        char* str = strdup(const_str);
        
        https://stackoverflow.com
        
        ```
        
        In the above example,Â const_strÂ is a pointer to a [[constant]] character string.
        
        We create a copy of the string usingÂ strdup()Â and store the pointer to the copy inÂ str.
        
        Now,Â strÂ is a pointer to a modifiable character string and can be safely modified.
        
        Alternatively, you can create your own version ofÂ strdup():
        
        ```cpp
        char* my_strdup(const char* const_str) {
            size_t len = strlen(const_str) + 1;
            char* str = new char[len];
            strcpy(str, const_str);
            return str;
        }
        
        ```
        
        In the above example,Â my_strdup()Â takes a pointer to a [[constant]] character string and creates a copy of the string using dynamic memory allocation withÂ new.
        
        The function returns a pointer to the copy, which can be safely modified.
        
    - [ ]  Array concatenation
- ğŸ§  View
    
    ĞŸĞ¾Ñ‡Ğ¸Ğ½Ğ°Ñ”Ğ¼Ğ¾ Ğ»ĞµĞºÑ†Ñ–Ñ Ğ· ĞĞĞŸ ÑƒÑ–Ñ–Ñ–
    
    ## Ğ”Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ğ¸Ğ¹ ĞºĞ»Ğ°ÑĞ¾Ğ²Ğ¸Ğ¹ Ñ‚Ğ¸Ğ¿
    
    Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° ÑĞºĞ°ÑÑŒ Ğ¿ĞµĞ²Ğ½Ğ°, ÑĞºĞ° Ğ² ÑĞ²Ğ¾Ñ—Ğ¹ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ñ–Ñ— Ğ·Ğ¼Ñ–Ğ½ÑÑ” Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ–, Ñ‰Ğ¾ Ğ²Ğ¸Ğ´Ñ–Ğ»ÑÑ”Ñ‚ÑŒÑÑ Ğ´Ğ»Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸ Ñ‚Ğ¸Ğ¿Ñƒ Ğ² Ğ·Ğ°Ğ»ĞµĞ¶Ğ½Ğ¾ÑÑ‚Ñ– Ğ²Ñ–Ğ´ Ğ¾Ğ±ÑÑĞ³Ñƒ Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ—. Ğ”Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ğ¸Ğ¹ Ğ¼Ğ°ÑĞ¸Ğ² - Ñ†Ğµ Ğ¼Ğ°ÑĞ¸Ğ², Ğ´Ğ»Ñ ÑĞºĞ¾Ğ³Ğ¾ Ğ¾Ğ³Ğ¾Ğ»Ğ¾ÑˆÑƒÑ”Ñ‚ÑŒÑÑ Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº Ñ– Ğ½Ğ° Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ ĞºĞ¾Ğ¼Ğ¿Ñ–Ğ»ÑÑ†Ñ–Ñ— Ñ„Ğ°Ğ¹Ğ»Ñƒ Ğ½Ğµ Ğ²Ğ¸Ğ´Ñ–Ğ»ÑÑ”Ñ‚ÑŒÑÑ Ğ½Ñ–ÑĞºĞ° Ğ¿Ğ°Ğ¼â€™ÑÑ‚ÑŒ, Ğ»Ğ¸ÑˆĞµ ĞºĞ¾Ğ¼Ñ–Ñ€ĞºĞ° Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ–, Ğ² ÑĞºÑ–Ğ¹ Ğ·Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ñ‚ÑŒÑÑ Ğ°Ğ´Ñ€ĞµÑĞ°, Ğ² ÑĞºÑ–Ğ¹ Ñƒ Ğ¼Ğ°Ğ¹Ğ±ÑƒÑ‚Ğ½ÑŒĞ¾Ğ¼Ñƒ Ğ±ÑƒĞ´Ğµ Ğ·Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ‚Ğ¸ÑÑŒ Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ. ĞŸÑ€Ğ¸ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ– ĞºĞ¾Ğ´Ñƒ Ğ±ÑƒĞ´Ğµ Ğ²Ğ¸Ğ´Ñ–Ğ»ÑÑ‚Ğ¸ÑÑŒ Ğ¾Ğ±ÑÑĞ³ Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ–, Ñ‚Ğ¾Ğ±Ñ‚Ğ¾ ĞºĞ¾Ğ»Ğ¸ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¾ new . ĞĞ³Ğ¾Ğ»Ğ¾ÑˆÑƒÑ”Ñ‚ÑŒÑÑ Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº Ñ– ÑĞºĞ°ÑÑŒ Ğ·Ğ¼Ñ–Ğ½Ğ½Ğ°, ÑĞºĞ° Ğ²Ğ¸Ğ´Ñ–Ğ»ÑÑ” Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ–. Ğ¯ĞºÑ‰Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ñ–Ğ»ÑÑ‚Ğ¾Ñ€ Ğ½Ğµ Ğ²Ğ¸Ğ´Ñ–Ğ»ÑÑ” Ğ¿Ğ°Ğ¼â€™ÑÑ‚ÑŒ, Ñ‚Ğ¾ Ğ¾Ñ‡Ğ¸Ñ‰Ğ°Ñ‚Ğ¸ Ğ²Ñ–Ğ½ Ñ—Ñ— Ñ‚ĞµĞ¶ Ğ½Ğµ Ğ·Ğ±Ğ¸Ñ€Ğ°Ñ”Ñ‚ÑŒÑÑ. ĞšĞ¾Ğ»Ğ¸ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ raw pointers, Ğ¾Ğ±Ğ¾Ğ²â€™ÑĞ·ĞºĞ¾Ğ²Ğ¾ Ğ¾Ñ‡Ğ¸Ñ‰ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ°Ğ¼â€™ÑÑ‚ÑŒ Ñ‡ĞµÑ€ĞµĞ· delete. Ğ”Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸ Ñ†Ğµ Ñ‚ĞµĞ¶ ÑĞ°Ğ¼Ğµ, Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ Ğ² ĞĞĞŸ.
    
    Ğ¯ĞºÑ‰Ğ¾ Ğ¼Ğ¸ Ğ² ĞºĞ»Ğ°ÑÑ– Ğ¾Ğ³Ğ¾Ğ»Ğ¾ÑĞ¸Ğ¼Ğ¾ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ğ¸Ğ¹ Ğ¼Ğ°ÑĞ¸Ğ², Ğ·Ğ° Ğ¹Ğ¾Ğ³Ğ¾ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¾Ğ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ²Ğ½Ñ–ÑÑ‚Ñ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ¼Ğ¸. Ğ¯ĞºÑ‰Ğ¾ Ğ² ĞºĞ»Ğ°ÑÑ– Ğ¾Ğ³Ğ¾Ğ»Ğ¾ÑĞ¸Ğ»Ğ¸ Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº, Ğ´Ğ»Ñ ÑĞºĞ¾Ğ³Ğ¾ Ğ±ÑƒĞ´ĞµĞ¼Ğ¾ Ğ²Ğ¸Ğ´Ñ–Ğ»ÑÑ‚Ğ¸ Ğ¿Ğ°Ğ¼â€™ÑÑ‚ÑŒ Ğ² ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ–, Ğ² Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ– **Ğ¾Ğ±Ğ¾Ğ²â€™ÑĞ·ĞºĞ¾Ğ²Ğ¾** Ğ²Ğ¸Ğ´Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ°Ğ±Ğ¾ Ğ¾Ñ‡Ğ¸Ñ‰ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ°Ğ¼â€™ÑÑ‚ÑŒ. Ğ¡Ğ°Ğ¼Ğµ Ğ´Ğ¾Ğ´Ğ°Ğ½Ğ½Ñ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ğ¸Ñ… Ğ¼Ğ°ÑĞ¸Ğ²Ñ–Ğ² Ñ– Ğ²Ğ¸Ğ´Ñ–Ğ»ÑÑ” Ğ´Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ğ¸Ğ¹ ĞºĞ»Ğ°ÑĞ¾Ğ²Ğ¸Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ²Ñ–Ğ´ Ñ–Ğ½ÑˆĞ¸Ñ…. Ğ Ñ‰Ğ¾ Ğ²Ñ–Ğ´Ğ±ÑƒĞ²Ğ°Ñ”Ñ‚ÑŒÑÑ, ĞºĞ¾Ğ»Ğ¸ Ğ¼Ğ¸ Ñ…Ğ¾Ñ‡ĞµĞ¼Ğ¾ ÑĞºĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¾Ğ±â€™Ñ”ĞºÑ‚ Ğ² Ñ–Ğ½ÑˆĞ¸Ğ¹ Ğ¾Ğ±â€™Ñ”ĞºÑ‚? Ğ‘ÑƒĞ´Ğµ Ğ¿Ğ¾Ğ±Ñ–Ñ‚Ğ¾Ğ²Ğ¾ ÑĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾ ĞºĞ¾Ğ¶Ğ½Ğ¸Ğ¹ Ñ€Ğ¾Ğ·Ñ€ÑĞ´ Ğ· Ğ¿ĞµÑ€ÑˆĞ¾Ğ³Ğ¾ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ñƒ Ñƒ Ñ–Ğ½ÑˆĞ¸Ğ¹. ĞŸÑ€Ğ¸ Ñ†ÑŒĞ¾Ğ¼Ñƒ, Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº Ğ²ĞºĞ°Ğ·ÑƒÑ” Ğ½Ğ° Ñ‚Ñƒ ÑĞ°Ğ¼Ñƒ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ–, Ñ‰Ğ¾ Ğ¼Ğ¾Ğ¶Ğµ Ğ¿Ñ€Ğ¸Ğ·Ğ²ĞµÑÑ‚Ğ¸ Ğ´Ğ¾ Ğ´ĞµÑĞºĞ¸Ñ… Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ğ¾Ğº Ğ°Ğ±Ğ¾ Ğ½Ğµ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ĞµĞ¹. 
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    class DynArray
    {
    private:
        int *array;
        int n;
    
    public:
        DynArray(int count);
        ~DynArray();
        friend void show(DynArray obj, int n);
    };
    
    DynArray::DynArray(int count)
    {
        n = count;
        array = new int[n];
    }
    DynArray::~DynArray()
    {
        delete[] array;
    }
    void show(DynArray obj, int n)
    {
        for (int i = 0; i < n; i++)
            cout << obj.array[i] << " ";
    }
    
    int main()
    {
        DynArray obj1(5);
        DynArray obj2 = obj1;
        return 0;
    }
    ```
    
    ## ĞšĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ¸ ĞºĞ¾Ğ¿Ñ–Ñ—
    
    ĞšĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ ĞºĞ¾Ğ¿Ñ–Ñ— - Ñ‰Ğµ Ğ¾Ğ´Ğ¸Ğ½ Ğ²Ğ¸Ğ´ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ°, ÑĞºĞ¸Ğ¹ Ğ²Ğ¸ĞºĞ¾Ğ½ÑƒÑ” Ñ‚Ñƒ ÑĞ°Ğ¼Ñƒ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ, Ñ‚Ğ¾Ğ±Ñ‚Ğ¾ ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ” Ğ¾Ğ±â€™Ñ”ĞºÑ‚, Ğ°Ğ»Ğµ Ğ²Ñ–Ğ½ Ğ¿ĞµÑ€ĞµĞ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ñ– Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ ÑĞ°Ğ¼Ğµ Ğ´Ğ»Ñ ĞºĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ñ–Ğ². ĞšĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ ĞºĞ¾Ğ¿Ñ–Ñ— Ğ·Ğ° Ğ·Ğ°Ğ¼Ğ¾Ğ²Ñ‡ÑƒĞ²Ğ°Ğ½Ğ½ÑĞ¼ ÑÑ‚Ğ²Ğ¾Ñ€ÑƒÑ” Ğ¿Ğ¾Ğ±Ñ–Ñ‚Ğ¾Ğ²Ñƒ ĞºĞ¾Ğ¿Ñ–Ñ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ğ°. ĞŸÑ€Ğ¸ Ğ²Ğ¸ĞºĞ»Ğ¸ĞºÑƒ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ— ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ”Ñ‚ÑŒÑÑ ĞºĞ¾Ğ¿Ñ–Ñ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ğ°, Ğ·Ğ²Ğ¸Ñ‡Ğ°Ğ¹Ğ½Ğ¸Ğ¹ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ Ğ½Ğµ Ğ²Ğ¸ĞºĞ»Ğ¸ĞºĞ°Ñ”Ñ‚ÑŒÑÑ. ĞĞ°Ñ‚Ğ¾Ğ¼Ñ–ÑÑ‚ÑŒ ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ”Ñ‚ÑŒÑÑ ĞºĞ¾Ğ½ÑÑ‚ÑƒÑ€ĞºÑ‚Ğ¾Ñ€ ĞºĞ¾Ğ¿Ñ–Ñ— Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ğ°. ĞŸÑ€Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ğ½ĞµĞ½Ğ½Ñ– Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ñ–Ğ² Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ” Ñ‚Ğ¸Ğ¼Ñ‡Ğ°ÑĞ¾Ğ²Ğ¸Ğ¹ Ğ¾Ğ±â€™Ñ”ĞºÑ‚, ÑĞºĞ¸Ğ¹ Ğ·Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ” Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ, Ñ‰Ğ¾ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ñ‚ÑŒÑÑ.
    
    ```cpp
    class DynArray
    {
    private:
        int *array;
        int n;
    
    public:
        DynArray(int count);
        ~DynArray();
        DynArray::DynArray(const DynArray &obj);
        friend void show(DynArray);
    };
    
    DynArray::DynArray(const DynArray &obj)
    {
        n = obj.n;
        array = new int[n];
        for (int i = 0; i < n; i++)
        {
            array[i] obj.array[i];
        }
    }
    ```
    
    Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ñ‚ÑŒÑÑ Ğ¿Ñ€Ğ¸:
    
    - Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—
    - Ñ–Ğ½Ñ–Ñ†Ñ–Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ğ° Ñ–Ğ½ÑˆĞ¸Ğ¼ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ğ¾Ğ¼
    - Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ²ĞµÑ€Ğ½ĞµĞ½Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ”Ñ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ğ°
    
    ĞšĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ ĞºĞ¾Ğ¿Ñ–Ñ— Ğ½Ğµ Ğ²Ğ¿Ğ»Ğ¸Ğ²Ğ°Ñ” Ğ½Ğ° Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ Ğ¿Ñ€Ğ¸ÑĞ²Ğ¾Ñ”Ğ½Ğ½Ñ, Ğ° ÑĞ°Ğ¼Ğµ Ğ·Ğ½Ğ°Ğº =. Ğ¦Ğµ Ğ¼Ğ¸ Ñ€Ğ¾Ğ·Ğ³Ğ»ÑĞ½ĞµĞ¼Ğ¾ Ñ‚Ñ€Ğ¾Ñ…Ğ¸ Ğ¿Ñ–Ğ·Ğ½Ñ–ÑˆĞµ
    
    ## Ğ—Ğ²â€™ÑĞ·Ğ°Ğ½Ñ– ÑĞ¿Ğ¸ÑĞºĞ¸. Linked lists
    
    Ğ¢Ğ¸Ğ¿ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‡Ğ½Ğ¾ Ğ²Ğ¸Ğ´Ñ–Ğ»ĞµĞ½Ğ¾Ñ— Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ–. Ğ¦Ğµ Ñ‚Ğ¸Ğ¿ Ğ´Ğ°Ğ½Ğ¸Ñ…, Ñ‰Ğ¾ ÑĞºĞ»Ğ°Ğ´Ğ°Ñ”Ñ‚ÑŒÑÑ Ğ· Ğ´Ğ²Ğ¾Ñ… Ğ·Ğ¼Ñ–Ğ½Ğ½Ğ¸Ñ…, Ñ‰Ğ¾ Ğ¼Ñ–ÑÑ‚ÑÑ‚ÑŒ Ğ² ÑĞ¾Ğ±Ñ– Ğ´Ğ°Ğ½Ñ– Ñ‚Ğ° Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡ĞºĞ¸Ğº Ğ½Ğ° Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚. Ğ¢Ğ°ĞºĞ¸Ğ¹ ÑĞ¾Ğ±Ñ– Ğ¿Ğ¾Ñ‚ÑĞ³, ĞºĞ¾Ğ¶ĞµĞ½ Ğ²Ğ°Ğ³Ğ¾Ğ½ Ğ¼Ñ–ÑÑ‚Ğ¸Ñ‚ÑŒ ÑĞºÑ–ÑÑŒ Ğ´Ğ°Ğ½Ñ– Ñ– Ğ²ĞºĞ°Ğ·ÑƒÑ” Ğ½Ğ° Ğ°Ğ´Ñ€ĞµÑÑƒ ĞºĞ¾Ğ¼Ñ–Ñ€ĞºĞ¸, Ğ´Ğµ Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒÑÑ Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ Ğ²Ğ°Ğ³Ğ¾Ğ½. Ğ”Ğ¾ÑÑƒÑ‚Ğ¿ Ğ´Ğ¾ ÑĞ¿Ğ¸ÑĞºÑƒ Ğ²Ğ¸ĞºĞ¾Ğ½ÑƒÑ”Ñ‚ÑŒÑÑ Ñ‡ĞµÑ€ĞµĞ· Ğ¿Ğ¾ĞºĞ°Ğ¶ÑÑ‡Ğ¸Ğº, ÑĞºĞ¸Ğ¹ Ğ¼Ñ–ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ñ€ĞµÑÑƒ Ğ¿ĞµÑ€ÑˆĞ¾Ğ³Ğ¾ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñƒ ÑĞ¿Ğ¸ÑĞºÑƒ. ĞŸÑ€Ğ¸ ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ– ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ° Ğ¼Ğ¸ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ·Ğ½Ğ°Ñ”Ğ¼Ğ¾ Ğ´Ğµ Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒÑÑ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¿Ğ¾Ñ‚ÑĞ³Ñƒ Ñ– Ñ‡Ñ–Ñ‚ĞºĞ¾ Ğ¼Ğ¾Ğ¶ĞµĞ¼Ğ¾ Ğ·Ğ½Ğ°Ñ‚Ğ¸ Ğ´Ğµ Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒÑÑ ĞºĞ¾Ğ¶ĞµĞ½ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚. Ğ’ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ¾Ğ±â€™Ñ”ĞºÑ‚Ñƒ Ñ†ÑŒĞ¾Ğ³Ğ¾ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¼Ğ¸ Ğ½Ğµ Ğ·Ğ½Ğ°Ñ”Ğ¼Ğ¾ ÑĞºÑ–Ğ»ÑŒĞºĞ¸ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ–Ğ² Ñƒ Ğ½Ğ°Ñ Ğ±ÑƒĞ´Ğµ Ğ² ÑĞ¿Ğ¸ÑĞºÑƒ. Ğ¡Ñ‚Ğ²Ğ¾Ñ€ÑÑ”Ğ¼Ğ¾ Ğ»Ğ¸ÑˆĞµ Ğ¾Ğ±â€™Ñ”ĞºÑ‚, ÑĞºĞ¸Ğ¹ Ğ¼Ñ–ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ñ€ĞµÑÑƒ Ğ¿ĞµÑ€ÑˆĞ¾Ğ³Ğ¾ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°. Ğ ĞºÑ–Ğ»ÑŒĞºÑ–ÑÑ‚ÑŒ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ–Ğ² Ğ²Ğ¶Ğµ Ğ²Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ñ‚ÑŒÑÑ Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ– Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ ĞºĞ¾Ğ´Ñƒ.
    
    Ğ¢Ğ¸Ğ¿Ğ¸ ÑĞ¿Ğ¸ÑĞºÑ–Ğ²:
    
    - Ğ¾Ğ´Ğ½Ğ¾Ğ·Ğ²â€™ÑĞ·Ğ½Ğ¸Ğ¹ Ğ»Ñ–Ğ½Ñ–Ğ¹Ğ½Ğ¸Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº - ĞšĞ¾Ğ¶ĞµĞ½ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¼Ğ°Ñ” Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº Ğ½Ğ° Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚, Ğ¾ÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¼Ğ°Ñ” Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº NULL. Ğ¡Ñ…Ğ¾Ğ¶Ğµ Ğ½Ğ° Ğ·Ğ²Ğ¸Ñ‡Ğ°Ğ¹Ğ½Ñƒ Ñ‡ĞµÑ€Ğ³Ñƒ Ğ² Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ñ– (queue)
    - Ğ¾Ğ´Ğ½Ğ¾Ğ·Ğ²â€™ÑĞ·Ğ½Ğ¸Ğ¹ Ñ†Ğ¸ĞºĞ»Ñ–Ñ‡Ğ½Ğ¸Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº - ĞÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ²ĞºĞ°Ğ·ÑƒÑ” Ğ½Ğ° Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚. Ğ¢Ğ°Ğº ÑĞ°Ğ¼Ğ¾, ĞºĞ¾Ğ¶Ğ½Ğ¸Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¼Ğ°Ñ” Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº Ğ½Ğ° Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚
    - Ğ´Ğ²Ğ¾Ğ·Ğ²â€™ÑĞ·Ğ½Ğ¸Ğ¹ Ğ»Ñ–Ğ½Ñ–Ğ¹Ğ½Ğ¸Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº - ĞšĞ¾Ğ¶ĞµĞ½ Ğ· Ğ²ÑƒĞ·Ğ»Ñ–Ğ² Ğ¼Ğ°Ñ” Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡ĞºĞ¸ Ğ½Ğ° Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ Ñ– Ğ¿Ğ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚. Ğ—Ğ½Ğ°Ñ…Ğ¾Ğ´ÑÑ‡Ğ¸ÑÑŒ Ğ² Ğ¿ĞµĞ²Ğ½Ğ¾Ğ¼Ñƒ Ğ²ÑƒĞ·Ğ»Ñ–, Ğ¼Ğ¸ Ğ¼Ğ¾Ğ¶ĞµĞ¼Ğ¾ Ğ¿ĞµÑ€ĞµĞ¹Ñ‚Ğ¸ ÑĞº Ğ´Ğ¾ Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾, Ñ‚Ğ°Ğº Ñ– Ğ´Ğ¾ Ğ¿Ğ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½ÑŒĞ¾Ğ³Ğ¾ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñƒ
    - Ğ´Ğ²Ğ¾Ğ·Ğ²â€™ÑĞ·Ğ½Ğ¸Ğ¹ Ñ†Ğ¸ĞºĞ»Ñ–Ñ‡Ğ½Ğ¸Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº - ĞšĞ¾Ğ¶ĞµĞ½ Ğ· Ğ²ÑƒĞ·Ğ»Ñ–Ğ² Ğ¼Ğ°Ñ” Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸Ğº Ğ½Ğ° Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ Ñ– Ğ¿Ğ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚. ĞÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¿Ğ¾ĞºĞ°Ğ·ÑƒÑ” Ğ½Ğ° Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹
    
    Ğ Ñ–Ğ·Ğ½Ğ¸Ñ†Ñ Ğ¼Ñ–Ğ¶ ÑĞ¿Ğ¸ÑĞºĞ°Ğ¼Ğ¸ Ñ‚Ğ° Ğ¼Ğ°ÑĞ¸Ğ²Ğ°Ğ¼Ğ¸. Ğ¡Ğ¿Ğ¸ÑĞºĞ¸ Ğ¿Ğ¾Ğ»ÑĞ³Ğ°ÑÑ‚ÑŒ Ğ² Ñ‚Ğ¾Ğ¼Ñƒ, Ñ‰Ğ¾ ĞºĞ¾Ğ¶ĞµĞ½ Ğ²ÑƒĞ·Ğ¾Ğ» Ğ¼Ğ°Ñ” Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ Ğ´Ğµ Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒÑÑ Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹ Ñ– Ğ¿Ğ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ Ğ²ÑƒĞ·Ğ¾Ğ». Ğ›Ğ¾Ğ³Ñ–Ñ‡Ğ½Ğ¾ ÑƒÑĞ²Ğ¸Ñ‚Ğ¸, Ñ‰Ğ¾ Ñ†Ñ– ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¸ Ğ² Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ– Ğ½Ğµ Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´ÑÑ‚ÑŒÑÑ Ğ¾Ğ´Ğ¸Ğ½ Ğ·Ğ° Ğ¾Ğ´Ğ½Ğ¸Ğ¼. Ğ¢Ğ¾Ğ±Ñ‚Ğ¾, Ñ” Ğ² Ğ½Ğ°Ñ Ğ´ĞµÑÑŒ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ¿Ğ°Ğ¼â€™ÑÑ‚Ñ–, Ğ² ÑĞºÑ–Ğ¹ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹ Ğ²ÑƒĞ·Ğ¾Ğ» Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ¼Ñ–ÑÑ†Ñ–, Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¹ Ğ² Ñ–Ğ½ÑˆĞ¾Ğ¼Ñƒ Ñ– Ñ‚Ğ°Ğº Ğ´Ğ°Ğ»Ñ–. ĞĞ»Ğµ Ğ²ÑÑ– Ğ²Ğ¾Ğ½Ğ¸ Ğ¿Ğ¾ Ñ‡ĞµÑ€Ğ·Ñ– Ğ²ĞºĞ°Ğ·ÑƒÑÑ‚ÑŒ Ğ¾Ğ´Ğ¸Ğ½ Ğ½Ğ° Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾. Ğ† ÑĞºÑ‰Ğ¾ Ğ½Ğ°Ğ¼ Ñ‚Ñ€ĞµĞ±Ğ° Ğ´ĞµÑÑŒ Ğ´Ğ¾Ğ´Ğ°Ñ‚Ğ¸ ÑĞºĞ¸Ğ¹ÑÑŒ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚, Ğ¼Ğ¸ Ğ·Ğ¼Ñ–Ğ½ÑÑ”Ğ¼Ğ¾ Ğ¿Ğ¾ĞºĞ°Ğ¶Ñ‡Ğ¸ĞºĞ¸ Ñ– Ğ²ÑÑ‚Ğ°Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ñ†ÑŒĞ¾Ğ³Ğ¾ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ° ĞºÑƒĞ´Ğ¸ÑÑŒ Ñ‚Ğ°Ğ¼.
    
    ĞŸÑ€Ğ¸ĞºĞ»Ğ°Ğ´ Ğ²ÑƒĞ·Ğ»Ğ° ÑĞ¿Ğ¸ÑĞºÑƒ
    
    ```cpp
    struct Node
    {
    private:
        struct fieldl;
        int field2;
        Node *ptr;
    };
    
    class Node
    {
    private:
        int field;
        class Node *ptr;
        friend class List;
    };
    ```
    
    # Ğ”Ğ¾Ğ´Ğ¾Ğ¼Ñƒ: figure out Stack and Queue data types
    
    ---
    
    ## 
    
- ğŸ«€ Review



---

links: [[112f ĞĞ±'Ñ”ĞºÑ‚Ğ¾ Ğ¾Ñ€Ñ–Ñ”Ğ½Ñ‚Ğ¾Ğ²Ğ°Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼ÑƒĞ²Ğ°Ğ½Ğ½Ñ]]

