"""
- –†–æ–∑—Ä–æ–±–∏—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–Ω–µ –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è, –≤ —è–∫–æ–º—É —Ä–µ–∞–ª—ñ–∑—É—î—Ç—å—Å—è –∞–ª–≥–æ—Ä–∏—Ç–º –æ–±—Ö–æ–¥—É –≥—Ä–∞—Ñ—É –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–æ—à—É–∫—É –≤ –≥–ª–∏–±–∏–Ω—É. –ü–µ—Ä–µ–¥–±–∞—á–∏—Ç–∏, —â–æ –≥—Ä–∞—Ñ –º–æ–∂–µ –±—É—Ç–∏ —è–∫ –æ—Ä—ñ—î–Ω—Ç–æ–≤–∞–Ω–∏–π, —Ç–∞–∫ —ñ –Ω–µ–æ—Ä—ñ—î–Ω—Ç–æ–≤–∞–Ω–∏–π. –í –ø—Ä–æ—Ü–µ—Å—ñ –ø–æ—à—É–∫—É –º–∞—î –±—É—Ç–∏ —Å—Ñ–æ—Ä–º–æ–≤–∞–Ω–æ –ª—ñ—Å –ø–æ—à—É–∫—É –≤ –≥–ª–∏–±–∏–Ω—É. –î–ª—è —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó –º–∞—î –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏—Å—è —Å—Ç–µ–∫. –ü—Ä–æ–≥—Ä–∞–º–Ω–µ –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è –º–∞—î –±—É—Ç–∏ –ø–æ–±—É–¥–æ–≤–∞–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–≥–æ –∫–ª–∞—Å—É, —è–∫–∏–π –ø–æ–≤–∏–Ω–µ–Ω –¥–æ–∑–≤–æ–ª—è—Ç–∏ –≤–∏–∑–Ω–∞—á–∞—Ç–∏ –≥—Ä–∞—Ñ, –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ –ø–æ—à—É–∫ –≤ –≥–ª–∏–±–∏–Ω—É, –≤–∏–≤–æ–¥–∏—Ç–∏ –ø–æ–±—É–¥–æ–≤–∞–Ω–∏–π –ª—ñ—Å –ø–æ—à—É–∫—É –≤ –≥–ª–∏–±–∏–Ω—É, –≤–∏–≤–æ–¥–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ö–æ–¥—É —Ç–æ—â–æ.
- –†–æ–∑—Ä–æ–±–∏—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–Ω–µ –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è, –≤ —è–∫–æ–º—É —Ä–µ–∞–ª—ñ–∑—É—î—Ç—å—Å—è –∞–ª–≥–æ—Ä–∏—Ç–º –æ–±—Ö–æ–¥—É –≥—Ä–∞—Ñ—É –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–æ—à—É–∫—É –≤ —à–∏—Ä–∏–Ω—É. –ü–µ—Ä–µ–¥–±–∞—á–∏—Ç–∏, —â–æ –≥—Ä–∞—Ñ –º–æ–∂–µ –±—É—Ç–∏ —è–∫ –æ—Ä—ñ—î–Ω—Ç–æ–≤–∞–Ω–∏–π, —Ç–∞–∫ —ñ –Ω–µ–æ—Ä—ñ—î–Ω—Ç–æ–≤–∞–Ω–∏–π. –í –ø—Ä–æ—Ü–µ—Å—ñ –ø–æ—à—É–∫—É –º–∞—î –±—É—Ç–∏ —Å—Ñ–æ—Ä–º–æ–≤–∞–Ω–æ –¥–µ—Ä–µ–≤–æ –ø–æ—à—É–∫—É –≤ —à–∏—Ä–∏–Ω—É. –î–ª—è —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó –º–∞—î –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏—Å—è —á–µ—Ä–≥–∞. –ü—Ä–æ–≥—Ä–∞–º–Ω–µ –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è –º–∞—î –±—É—Ç–∏ –ø–æ–±—É–¥–æ–≤–∞–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–≥–æ –∫–ª–∞—Å—É, —è–∫–∏–π –ø–æ–≤–∏–Ω–µ–Ω –¥–æ–∑–≤–æ–ª—è—Ç–∏ –≤–∏–∑–Ω–∞—á–∞—Ç–∏ –≥—Ä–∞—Ñ, –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ –ø–æ—à—É–∫ –≤ —à–∏—Ä–∏–Ω—É, –≤–∏–≤–æ–¥–∏—Ç–∏ –ø–æ–±—É–¥–æ–≤–∞–Ω–µ –¥–µ—Ä–µ–≤–æ –ø–æ—à—É–∫—É –≤ —à–∏—Ä–∏–Ω—É, –≤–∏–≤–æ–¥–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ö–æ–¥—É —Ç–æ—â–æ.
- –£ –∑–∞–¥–∞–Ω–æ–º—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º –≥—Ä–∞—Ñ—ñ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ —É –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—å –∫–æ–∂–Ω—ñ–π –≤–µ—Ä—à–∏–Ω—ñ –¥–µ—è–∫–µ —Ü—ñ–ª–µ —á–∏—Å–ª–æ (–º–æ–∂–µ –±—É—Ç–∏ —è–∫ –≤—ñ–¥‚Äô—î–º–Ω–∏–º, —Ç–∞–∫ —ñ –¥–æ–¥–∞—Ç–Ω–∏–º). –í–∏–∑–Ω–∞—á–∏—Ç–∏ —Ç–∞–∫—ñ —à–ª—è—Ö–∏ –º—ñ–∂ –ø–∞—Ä–∞–º–∏ –≤–µ—Ä—à–∏–Ω, —è–∫—ñ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –≤—Å—ñ—Ö —á–∏—Å–µ–ª –∑ –∫–æ–∂–Ω–æ—ó –≤–µ—Ä—à–∏–Ω–∏ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –æ—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–¥–∞–Ω–µ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º –∑–Ω–∞—á–µ–Ω–Ω—è.
- –ó–∞–¥–∞–Ω–æ –¥–µ—è–∫–∏–π –Ω–∞–±—ñ—Ä –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–æ–¥–∞—Ç–∏ 3, –ø–æ–º–Ω–æ–∂–∏—Ç–∏ –Ω–∞ 2), —è–∫—ñ –º–æ–∂—É—Ç—å –±—É—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω—ñ –Ω–∞–¥ –æ–ø–µ—Ä–∞–Ω–¥–æ–º. –í–∏–∑–Ω–∞—á–∏—Ç–∏ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –Ω–∞–±—ñ—Ä –æ–ø–µ—Ä–∞—Ü—ñ–π, –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —è–∫–æ–≥–æ –º–æ–∂–Ω–∞ –æ—Ç—Ä–∏–º–∞—Ç–∏ –∑ –æ–¥–Ω–æ–≥–æ –∑–∞–¥–∞–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∞ —á–∏—Å–ª–æ b. –Ø–∫—â–æ —Ç–∞–∫–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∑–∞–¥–∞–Ω–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º –Ω–∞–±–æ—Ä—É –æ–ø–µ—Ä–∞—Ü—ñ–π –≤–∏–∫–æ–Ω–∞—Ç–∏ –Ω–µ–º–æ–∂–ª–∏–≤–æ, —Ç–æ –≤–∏–≤–µ—Å—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è.
- –ì–µ–º–ø—Ç–æ–Ω-–ö–æ—Ä—Ç—Å—å–∫–∏–π –ª–∞–±—ñ—Ä–∏–Ω—Ç –ø–ª–æ—â–µ—é —É 60 –∞–∫—Ä—ñ–≤ –ø—Ä–∏–≤–µ—Ä—Ç–∞—î —É–≤–∞–≥—É –±–∞–≥–∞—Ç—å–æ—Ö —Ç—É—Ä–∏—Å—Ç—ñ–≤. –í–∞—à —Ç–æ–≤–∞—Ä–∏—à –ø–µ—Ä–µ–¥ —Ç–∏–º, —è–∫ –ø–æ—Ç—Ä–∞–ø–∏—Ç–∏ –¥–æ –æ–¥–Ω–æ–≥–æ –∑ —Ç–∞–∫–∏—Ö –ª–∞–±—ñ—Ä–∏–Ω—Ç—ñ–≤ —ñ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä—É–≤–∞—Ç–∏ —Å–≤–æ—ó –∑–¥—ñ–±–Ω–æ—Å—Ç—ñ, –≤–∏—Ä—ñ—à–∏–≤ –≤–∏–≤—á–∏—Ç–∏ –ø–ª–∞–Ω –ª–∞–±—ñ—Ä–∏–Ω—Ç—É —Ç–∞ –∑–∞–ø–∏—Ç–∞–≤ –í–∞—Å –ø—Ä–æ –¥–æ–ø–æ–º–æ–≥—É, —è–∫–∏–º —á–∏–Ω–æ–º –∑–Ω–∞–π—Ç–∏ —à–ª—è—Ö —É –ª–∞–±—ñ—Ä–∏–Ω—Ç—ñ. –ó–º–æ–¥–µ–ª—é–π—Ç–µ –ª–∞–±—ñ—Ä–∏–Ω—Ç –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –≤–µ—Ä—à–∏–Ω, —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å –≤—Ö–æ–¥—É –≤ –ª–∞–±—ñ—Ä–∏–Ω—Ç, –≤–∏—Ö–æ–¥—É, –≥–ª—É—Ö–∏–º –∫—É—Ç–∞–º, –≤—Å—ñ–º —Ç–æ—á–∫–∞–º –ª–∞–±—ñ—Ä–∏–Ω—Ç—É, –≤ —è–∫–∏—Ö —î –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –≤–∏–±–æ—Ä—É —à–ª—è—Ö—É, —Ç–∞ –∑‚Äô—î–¥–Ω–∞–Ω—å –¥–∞–Ω–∏—Ö –≤–µ—Ä—à–∏–Ω —Ä–µ–±—Ä–∞–º–∏, —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å —à–ª—è—Ö–∞–º —É –ª–∞–±—ñ—Ä–∏–Ω—Ç—ñ
"""


GRAPH_FILE_PATH = "D:/code/everything/University/y2t1/DSA/tasks/lb5/input.txt"
MAZE_FILE_PATH = "D:/code/everything/University/y2t1/DSA/tasks/lb5/maze.txt"


def breadthFirstSearch():
    from collections import defaultdict, deque

    class Graph:
        def __init__(self, directed=False):
            self.graph = defaultdict(list)
            self.directed = directed

        def addEdge(self, u, v):
            self.graph[u].append(v)
            if not self.directed:
                self.graph[v].append(u)

        def BFS(self, start):
            visited = set()
            queue = deque([start])

            while queue:
                vertex = queue.popleft()
                if vertex not in visited:
                    visited.add(vertex)
                    queue.extend(set(self.graph[vertex]) - visited)

            return visited

        def displayTree(self, start):
            visited = set()
            queue = deque([start])
            tree = defaultdict(list)

            while queue:
                vertex = queue.popleft()
                if vertex not in visited:
                    visited.add(vertex)
                    for neighbor in self.graph[vertex]:
                        if neighbor not in visited:
                            tree[vertex].append(neighbor)
                            queue.append(neighbor)

            return tree

        def displayResults(self, start):
            visited = self.BFS(start)
            print(f"BFS traversal: {visited}")

        def displayGraph(self):
            for key, value in self.graph.items():
                print(f"{key} üîó {', '.join(map(str, value))}")

        def loadFromFile(self, filename):
            with open(filename, "r") as file:
                for line in file:
                    u, v = line.strip().split()
                    self.addEdge(int(u), int(v))

    def main():
        g = None
        while True:
            print("\nBFS")
            print("1. Create a new graph")
            print("2. Add an edge")
            print("3. Display graph")
            print("4. Perform breadth-first search")
            print("5. Display breadth-first search tree")
            print("6. Exit")
            choice = int(input(": "))
            print()

            if choice == 1:
                print("1. Load from file")
                print("2. Create a new graph")
                # choice = int(input(": "))
                choice = 1

                if choice == 1:
                    # filename = input("Enter the filename: ")
                    filename = GRAPH_FILE_PATH
                    g = Graph()
                    g.loadFromFile(filename)
                elif choice == 2:
                    directed = input("Is the graph directed? (y/n): ") == "y"
                    g = Graph(directed)

            elif choice == 2:
                u = int(input("Enter the first vertex: "))
                v = int(input("Enter the second vertex: "))
                g.addEdge(u, v)

            elif choice == 3:
                g.displayGraph()

            elif choice == 4:
                v = int(input("Enter the starting vertex: "))
                g.displayResults(v)

            elif choice == 5:
                v = int(input("Enter the starting vertex: "))
                print()
                tree = dict(g.displayTree(v))
                for key, value in tree.items():
                    print(f"{key}: {value}")

            else:
                break

    main()


def depthFirstSearch():
    from collections import defaultdict

    class Graph:
        def __init__(self, directed=False):
            self.graph = defaultdict(list)
            self.directed = directed

        def addEdge(self, u, v):
            self.graph[u].append(v)
            if not self.directed:
                self.graph[v].append(u)

        def DFS(self, v, visited=None):
            if visited is None:
                visited = set()
            stack = [v]
            while stack:
                vertex = stack.pop()
                if vertex not in visited:
                    visited.add(vertex)
                    print(vertex, end=" ")
                    stack.extend(set(self.graph[vertex]) - visited)
            return visited

        def displayForest(self, v):
            print("Depth-first search forest:")
            self.DFS(v)
            print()

        def displayGraph(self):
            for key, value in self.graph.items():
                print(f"{key} üîó {', '.join(map(str, value))}")

        def loadFromFile(self, filename):
            with open(filename, "r") as file:
                for line in file:
                    u, v = line.strip().split()
                    self.addEdge(int(u), int(v))

    def main():
        g = None
        while True:
            print("\nDFS")
            print("1. Create a new graph")
            print("2. Add an edge")
            print("3. Display graph")
            print("4. Perform depth-first search")
            print("5. Display depth-first search forest")
            print("6. Exit")
            choice = int(input(": "))
            print()

            if choice == 1:
                print("1. Load from file")
                print("2. Create a new graph")
                # choice = int(input(": "))
                choice = 1

                if choice == 1:
                    # filename = input("Enter the filename: ")
                    filename = GRAPH_FILE_PATH
                    g = Graph()
                    g.loadFromFile(filename)
                elif choice == 2:
                    directed = input("Is the graph directed? (y/n): ") == "y"
                    g = Graph(directed)

            elif choice == 2:
                u = int(input("Enter the first vertex: "))
                v = int(input("Enter the second vertex: "))
                g.addEdge(u, v)

            elif choice == 3:
                g.displayGraph()

            elif choice == 4:
                v = int(input("Enter the starting vertex: "))
                g.DFS(v)
                print()

            elif choice == 5:
                v = int(input("Enter the starting vertex: "))
                print()
                g.displayForest(v)

            else:
                break

    main()


def getNumberBySumOfPaths():
    from collections import defaultdict

    class Graph:
        def __init__(self, directed=False):
            self.graph = defaultdict(list)
            self.directed = directed

        def addEdge(self, u, v):
            self.graph[u].append(v)
            if not self.directed:
                self.graph[v].append(u)

        def findPaths(self, start, targetSum):
            visited = set()
            path = []
            self._findPathsHelper(start, targetSum, visited, path)

        def _findPathsHelper(self, vertex, targetSum, visited, path):
            visited.add(vertex)
            path.append(vertex)

            if sum(path) == targetSum:
                print(path)

            for neighbor in self.graph[vertex]:
                if neighbor not in visited:
                    self._findPathsHelper(neighbor, targetSum, visited, path)

            path.pop()
            visited.remove(vertex)

        def displayGraph(self):
            for key, value in self.graph.items():
                print(f"{key} üîó {', '.join(map(str, value))}")

        def loadFromFile(self, filename):
            with open(filename, "r") as file:
                for line in file:
                    u, v = line.strip().split()
                    self.addEdge(int(u), int(v))

    def main():
        g = None
        while True:
            print("\nSUM")
            print("1. Create a new graph")
            print("2. Add an edge")
            print("3. Display graph")
            print("4. Find paths to target sum")
            print("5. Exit")
            choice = int(input(": "))
            print()

            if choice == 1:
                print("1. Load from file")
                print("2. Create a new graph")
                # choice = int(input(": "))
                choice = 1

                if choice == 1:
                    # filename = input("Enter the filename: ")
                    filename = GRAPH_FILE_PATH
                    g = Graph()
                    g.loadFromFile(filename)
                elif choice == 2:
                    directed = input("Is the graph directed? (y/n): ") == "y"
                    g = Graph(directed)

            elif choice == 2:
                u = int(input("Enter the first vertex: "))
                v = int(input("Enter the second vertex: "))
                g.addEdge(u, v)

            elif choice == 3:
                g.displayGraph()

            elif choice == 4:
                v = int(input("Enter the starting vertex: "))
                targetSum = int(input("Enter the target sum: "))
                g.findPaths(v, targetSum)

            else:
                break

    main()


def getMinimalNumberOfOperations():
    from collections import defaultdict, deque

    class Graph:
        def __init__(self, directed=False):
            self.graph = defaultdict(list)
            self.directed = directed

        def addEdge(self, u, v):
            self.graph[u].append(v)
            if not self.directed:
                self.graph[v].append(u)

        def minOperations(self, a, b, maxNumber=None):
            queue = deque([a])
            length = {a: 0}
            previous = {a: None}

            while queue:
                currentValue = queue.popleft()

                def tryPerforming(nextValue):
                    if maxNumber is not None and nextValue > maxNumber:
                        return
                    if nextValue in length:
                        return
                    queue.append(nextValue)
                    length[nextValue] = length[currentValue] + 1
                    previous[nextValue] = currentValue

                tryPerforming(currentValue + 1)
                tryPerforming(currentValue - 1)
                tryPerforming(currentValue * 2)
                if currentValue % 2 == 0:
                    tryPerforming(currentValue // 2)

                tryPerforming(currentValue * 3)
                if currentValue % 3 == 0:
                    tryPerforming(currentValue // 3)

                if b in length:
                    break

            path = [b]
            while path[-1] != a:
                path.append(previous[path[-1]])

            path.reverse()
            return path

        def displayGraph(self):
            for key, value in self.graph.items():
                print(f"{key} üîó {', '.join(map(str, value))}")

        def loadFromFile(self, filename):
            with open(filename, "r") as file:
                for line in file:
                    u, v = line.strip().split()
                    self.addEdge(int(u), int(v))

    def main():
        g = None
        while True:
            print("\nMIN")
            print("1. Create a new graph")
            print("2. Add an edge")
            print("3. Display graph")
            print("4. Determine min number of operations")
            print("5. Exit")
            choice = int(input(": "))
            print()

            if choice == 1:
                print("1. Load from file")
                print("2. Create a new graph")
                # choice = int(input(": "))
                choice = 1

                if choice == 1:
                    # filename = input("Enter the filename: ")
                    filename = GRAPH_FILE_PATH
                    g = Graph()
                    g.loadFromFile(filename)
                elif choice == 2:
                    directed = input("Is the graph directed? (y/n): ") == "y"
                    g = Graph(directed)

            elif choice == 2:
                u = int(input("Enter the first vertex: "))
                v = int(input("Enter the second vertex: "))
                g.addEdge(u, v)

            elif choice == 3:
                g.displayGraph()

            elif choice == 4:
                if g is not None:
                    a = int(input("Enter the starting number: "))
                    b = int(input("Enter the ending number: "))
                    path = g.minOperations(a, b)
                    print(f"{len(path)}: {path}")
                else:
                    print("No graph loaded.")

            else:
                break

    main()


def hamptonMaze():
    pass


def menu():
    while True:
        print("\nMake your choice")
        print("1. Show Breadth-First Search demonstration")
        print("2. Show Depth-First Search demonstration")
        print("3. Get the specified number by sum of paths")
        print("4. Get minimal number of operations")
        print("5. Hampton Court Maze")
        print("6. Exit")
        choice = int(input(": "))

        if choice == 1:
            breadthFirstSearch()
        elif choice == 2:
            depthFirstSearch()
        elif choice == 3:
            getNumberBySumOfPaths()
        elif choice == 4:
            getMinimalNumberOfOperations()
        elif choice == 5:
            hamptonMaze()
        else:
            break


menu()
