Складові програмування

- синтаксис мови програмування
- алгоритми та структури даних
- бібліотеки
- архітектура програмного забезпечення
- групова робота

Спортивне програмування пов'язане з олімпіадами. Програмування це така цікава штука. Зайшли на амазон букс і пошукали "programming", там був Python в більшості випадків. Коли ми говорили про програмування ми говорили про синтаксис. В школі. Мова програмування це інтсрумент шоб виконати якийсь алгоритм програмним кодом.

Далі маємо алгоритми та структури даних. Чого? Комп'ютери це як найкраща, так і найгірша річ шо ми придумали. Воно поки шо розуміє тіки 0 та 1. Вона завжди робе тільки те шо їй сказали. Тому і ДСА воно не зміниться можливо ніколи.

Далі є прикладні бібліотеки. Воно ближче до синтаксису, чого? Бібліотеки для кожної мови вони є конкретно для цієї мови тіки. Без знання бібліотек також далеко не поїдеш. Пайтон дуже відомий своїми бібліотеками. Він допомагає нам реалізовувати дуже багато речей всяких крутих цікавих. У пайтоні є бібліотеки чи не для всього на світі.

Далі йде архітектура ПЗ. Гадки не маю шо то. У нас буде така сама дисципліна колись там. Створити консольну штуку це багато розуму не треба. А коли є велика апка, має бути хтось, хто може бачити як воно має бути структуровано. Великий застосунок, в незалежності від мови, технологій, тощо, він все одно має бути керований певними стандартними правилами. Далі буде бізнес логіка апів, шаблони проєктування. Шоб зробити шось велике, треба зрозуміти як воно буде виглядати. Різниця між розумінням основ програмування, себто перших трьох пунктів, і розумінням архітектури величезна. Архітектурою займаються тім ліди.

Є групова робота над розробкою. В нас вже була дисципліна SS групова динаміка та комунікації. Це і так зрозуміло, будь який нормальний проєкт розробляється командно.

У цій дисципліні ми не будемо говорити про нічого окрім алгоритмів та структур даних. 😆 Цей блок ще можна розділити на алгоритми, та алгоритми для структур даних. Також троха будемо говорити про парадигми програмування. Буде в нас функціональне програмування основною парадигмою мабуть. Будемо говорити про якісь механізми, структури і як їх імплементувати шоб полегшити розробку нам.

Перша тема - Рекуретні послідовності

Рекурентні послідовності зустрічаються в житті досить часто. Уявімо шо є якась послідовність `a0, a1, ..., ai`. І є в нас формула за якою задається послідовність, скажімо `ai = 2^i`. Тобто це в нас `1, 2, 4, 8, ...`. А якшо формула це `ai = 2*ai-1`. Тоді ми зможемо знати елементи тіки якшо знати значення попереднього елементу. Послідовності така сама наче, тобто `1, 2, 4, 8, ...`. А якшо послідовність `3, 6, 12, ...` - так. А для `0, 0, 0, ...` - теж працює. Тобто треба якось перевизначитись. Найпростіше зробити через перший член - `ai=2*ai-1, a0=1`. Тоді мова буде йти тіки про оцю - `1, 2, 4, 8, ...`.

Найвідоміші рекурентні послідовності це числа фібоначі. `Fi = Fi-1+Fi-2, F0 && F1= 1`. Також фібоначі числа складаються у золотий перетин, про нього ми ще поговоримо. Шоб порахувати фібоначі - скіки комірок пам'яті треба? В класичному випадку потрібно Н комірок пам'яті. Шоб визначити Fn треба знати попередній елемент. Тобто шоб визначити Н треба обрахувати все від 1 до Н-1. Але як варіант шоб це оптимізувати може бути достатньо Н-2 і Н-1 тобто дві комірки пам'яті.

Зодача

![](https://i.imgur.com/fd12DkN.png)

Коротше перша лаба це про рекурсію. Ненавиджу рекурсію. Задача яку ми писали у класі:

```python
fib = [0] * 45


def solve(n: int, k: int) -> str:
    if (n == 0):
        return 'a'
    if (n == 1):
        return 'b'
    if (k <= fib[n-2]):
        return solve(n-2, k)
    return solve(n-1, k-fib[n-2])


def main():
    n, k, tests = 0, 0, 0
    fib[0] = 1
    fib[1] = 1
    for i in range(2, 45):
        fib[i] = fib[i-1] + fib[i-2]
    tests = int(input())
    while tests - 1:
        n, k = map(int, input().split())
        print(solve(n, k))


if __name__ == '__main__':
    main()
```

ООП нам тут ніякого не треба, просто функції бамбуримо і вирішуємо задачу. Курво а як їх вирішувати я гадки не маю. Мабуть рекурсію подивити, почитати.
